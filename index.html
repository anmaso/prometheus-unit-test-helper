<html>
<head>
  <title>SLO Unit Test Helper - Grafana Style</title>
</head>
<body>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
  <script src="tests.js"></script>

  <div class="main-container" id="app">
    <div class="config-panel">
      <h2>Test Configuration</h2>
      good events ({{good_length}} data points)<input v-model="good" size="100" />
      <div v-if="showSeriesValues" class="expanded-definition-mini">
        <code>{{expandedGood}}</code>
        <button @click="copyToClipboard(expandedGood)" class="copy-button" title="Copy good events to clipboard">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
      </div>
      <br/>
      bad events ({{bad_length}} data points)<input class="bad_events" v-model="bad" size="100" />
      <div v-if="showSeriesValues" class="expanded-definition-mini">
        <code class="bad_events">{{expandedBad}}</code>
        <button @click="copyToClipboard(expandedBad)" class="copy-button" title="Copy bad events to clipboard">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
      </div>
      <br/>
      Alert formula:
      <select v-model="selectedFormula">
        <option value="proportionRateOverN">Proportion Rate over N</option>
        <option value="countOverN">Count over N</option>
      </select>
      <br/> <!-- Added line break for better spacing -->
      <span class="alert alert1"></span>
      alert 1 window 
      <input v-model="short" size="5" />
      threshold
      <input v-model="threshold1" size="6" />
      <br/> <!-- Added line break for better spacing in narrower panel -->
      <span class="alert alert2"></span>
      alert 2 window 
      <input v-model="long" size="5" />
      threshold <input v-model="threshold2" size="6" />
      <br/> <!-- Added line break for better spacing -->
      <button @click="toggleHelpModal()">Help</button>
      <br/> <!-- Added line break for better spacing -->
      <input type="checkbox" id="highlightToggleCheckbox" v-model="highlightEnabled" />
      <label for="highlightToggleCheckbox" style="cursor: pointer;">Highlight alert</label>
      <br/> <!-- Added line break for better spacing -->
      <input type="checkbox" id="debounceToggleCheckbox" v-model="debounceEnabled" />
      <label for="debounceToggleCheckbox" style="cursor: pointer;">Debounce alert</label>
      <label for="debounceTimeInput" style="margin-left: 10px;">window </label>
      <input id="debounceTimeInput" v-model="debounceTime" size="3" min="0" />
      <br/> <!-- Added line break for better spacing -->
      <input type="checkbox" id="showSeriesValuesCheckbox" v-model="showSeriesValues" />
      <label for="showSeriesValuesCheckbox" style="cursor: pointer;">Show series values</label>
      <br/> <!-- Added line break for better spacing -->
      <input type="checkbox" id="showTimeFormatCheckbox" v-model="showTimeFormat" />
      <label for="showTimeFormatCheckbox" style="cursor: pointer;">Show time format</label>

      <!-- Help Modal -->
      <div v-if="showHelpModal" class="modal-overlay" @click.self="toggleHelpModal()">
        <div class="modal-content">
          <span class="close-button" @click="toggleHelpModal()">&times;</span>
          <h2>Help - SLO Unit Test Helper</h2>
          <p>This tool helps you visualize SLO (Service Level Objective) scenarios by defining series of good and bad events over time.</p>

          <h4>Input Fields:</h4>
          <ul>
            <li><strong>Bad/Good Events:</strong> Define event series using a prometheus alert format. Each segment is <code>[initial]+[increment]x[steps]</code>.
              <ul>
                <li><code>initial</code>: The starting value for this segment. Use <code>#</code> to use the last value from the previous segment.</li>
                <li><code>increment</code>: The value to add at each step within this segment.</li>
                <li><code>steps</code>: The number of data points in this segment.</li>
                <li>Example: <code>0+0x60 150+150x10 #+0x60</code> creates a series starting at 0 for 60 steps, then jumps to 150 and increments by 150 for 10 steps, then continues from the last value with 0 increment for 60 steps.</li>
              </ul>
            </li>
            <li><strong>Threshold 1 & 2:</strong> These are the threshold values for <code>alert1</code> and <code>alert2</code> series respectively.
              <ul>
                <li>For <strong>Proportion Rate over N</strong>: Thresholds are typically small numbers (e.g., 0.01 for 1%).</li>
                <li>For <strong>Count over N</strong>: Thresholds represent a sum of bad events (e.g., 100).</li>
              </ul>
            </li>
            <li><strong>Alert1 Range (short):</strong> The window size (number of data points) used to calculate the <code>alert1</code> series.</li>
            <li><strong>Alert2 Range (long):</strong> The window size for the <code>alert2</code> series.</li>
          </ul>

          <h4>Controls:</h4>
          <ul>
            <li><strong>Render Button:</strong> Click to update the chart with the current input configurations. You can also press Enter in the 'bad events' or 'good events' input fields.</li>
            <li><strong>Highlight Alert Checkbox:</strong> Toggles the visual highlighting on the chart. Highlighting occurs when <em>both</em> <code>alert1</code> is above <code>threshold1</code> AND <code>alert2</code> is above <code>threshold2</code>.</li>
            <li><strong>Debounce Alert Checkbox:</strong> Enables alert debouncing. If checked, highlights will only appear if the alert condition (<code>alert1</code> > <code>threshold1</code> AND <code>alert2</code> > <code>threshold2</code>) persists for the specified "Debounce Time".</li>
            <li><strong>Debounce Time (steps):</strong> The number of consecutive data points an alert condition must be true before it's visually highlighted (if "Debounce alert" is checked).</li>
             <li><strong>Formula Selector:</strong> Choose the calculation method for <code>alert1</code> and <code>alert2</code> series:
              <ul>
                <li><strong>Proportion Rate over N:</strong> Calculates <code>sum(bad events in window) / (sum(bad events in window) + sum(good events in window))</code>. This is a ratio, typically between 0 and 1.</li>
                <li><strong>Count over N:</strong> Calculates <code>sum(bad events in window)</code>. This is an absolute count/sum of bad events over the specified window. It only uses the 'bad events' series for its calculation.</li>
              </ul>
            </li>
          </ul>

          <p>The chart displays various series including the raw bad/good event counts (hidden by default), their rates, the calculated alert proportions, and the defined thresholds.</p>
        </div>
      </div>
    </div>
    <div class="chart-container">
      <ChartComponent
        :alert1="chartData.alert1"
        :alert2="chartData.alert2"
        :threshold1="chartData.threshold1"
        :threshold2="chartData.threshold2"
        :bad="chartData.bad"
        :good="chartData.good"
        :rate_bad="chartData.rate_bad"
        :rate_good="chartData.rate_good"
        :labels="chartData.labels"
        :highlight-enabled="highlightEnabled"
        :debounce-enabled="debounceEnabled"
        :debounce-time="debounceTime"
        :show-time-format="showTimeFormat"
      />
    </div>
    <!-- Series Values Section -->
    <div v-if="showSeriesValues" class="series-values-container">
        <div class="series-data">
          <h4>Step Values:</h4>
          <div class="series-item">
            <span class="index">step</span> <span class="value">good</span><span class="value bad_events">bad</span><span class="value">rate good</span></span><span class="value bad_events">rate bad</span>
          </div>
          <div v-for="(value, index) in step_values.good_values" :key="'good-' + index" class="series-item">
            <span class="index">{{index}}:</span> <span class="value">{{value}}</span><span class="value bad_events">{{step_values.bad_values[index]}}</span><span class="value">{{step_values.rate_good[index]}}</span></span><span class="value bad_events">{{step_values.rate_bad[index]}}</span>

          </div>
        </div>

    </div><!--- end of series values section -->
  </div>
  
  <script>
  let fn = {
    serieDefFromString: (definition) => {
      const parts = definition.trim().split(/\s+/).filter(p => p !== "");
      const seriesSpec = [];

      // Regex for initialValue, operator (+ or -), incrementValue, stepsValue
      // Examples: -2+4x3, 1-2x4, #+1x5
      const opRegex = /^([#]|-?\d*\.?\d+)([+-])(\d*\.?\d+)x(\d+)$/;

      // Regex for initialValue, stepsValue (for numeric shorthand or special repeats)
      // Examples: 1x4 (numeric), _x3 (special), stalex3 (special), #x2 (numeric repeat)
      const repeatRegex = /^([#\w_.-]+)x(\d+)$/;

      const numericLiteralRegex = /^[+-]?\d+(\.\d+)?$/;

      for (const p of parts) {
        let match;

        if ((match = p.match(opRegex))) {
          // Handles 'a+bxn', 'a-bxn', '#+bxn'
          const initial = match[1] === "#" ? "#" : parseFloat(match[1]);
          const operator = match[2];
          const increment = parseFloat(match[3]);
          const steps = parseInt(match[4], 10); // n further samples
          seriesSpec.push({
            initial: initial,
            increment: operator === '-' ? -increment : increment,
            steps: steps // n further samples
          });
        } else if ((match = p.match(repeatRegex))) {
          // Handles 'axn' (numeric shorthand) and '_xn', 'stalexn' (special repeats), '#xn' (numeric repeat)
          const valueStr = match[1];
          const n = parseInt(match[2], 10);

          if (valueStr === "_") {
            // '_xn' -> n repetitions of '_'
            seriesSpec.push({ initial: '_', increment: '_', steps: n });
          } else if (valueStr === "#") {
            // '#xn' -> '#' then n further instances of that value (effectively repeating last numeric value n+1 times)
            seriesSpec.push({ initial: '#', increment: 0, steps: n });
          } else if (numericLiteralRegex.test(valueStr)) {
            // Numeric 'axn' -> 'a+0xn' (a then n further 'a's)
            seriesSpec.push({ initial: parseFloat(valueStr), increment: 0, steps: n, });
          } else {
            console.warn(`Unrecognized value in repeat segment: ${p}. Treating as ${n} repetitions of literal "${valueStr}".`);
            seriesSpec.push({ initial: valueStr, type: 'special_repeat', steps: n });
          }
        } else if (p === "#") {
          seriesSpec.push({ initial: "#", increment: 0, steps: 0 }); // Single '#'
        } else if (p === "_") {
          seriesSpec.push({ initial: "_", increment: '_' });
        } else if (numericLiteralRegex.test(p)) {
          seriesSpec.push({ initial: parseFloat(p),  increment: 0, steps: 0 }); // Single number
        } else {
          console.warn(`Unrecognized segment: ${p}. Treating as a single literal string.`);
          seriesSpec.push({ initial: p, type: 'special_single' }); // Treat unknown as single special
        }
      }
      return seriesSpec;
    },
    makeSerieConstant: (value, steps) =>
      fn.makeSerie([{
        initial: value,
        increment: 0,
        steps:steps-1,
      }]),
    makeSerie: (spec) => {
      let values = [];
      spec.forEach((s) => {
        let len = values.length;
        if (s.initial == "#") {
          if (len==0){
            values = [0];
          }else{
            values.push(values[values.length - 1] + s.increment);
          }
        } else {
          if (s.initial === '_') {
            // Handle special underscore values directly
            values.push(s.initial);
          } else {
            values.push( (len?values[values.length - 1]:0) + s.initial);
          }
        }
        if (len>0 && values[len] < values[len-1]){
          values[len]=values[len-1]+values[len]
        }
        for (i = 0; i < s.steps; i++) {
          if (s.increment=='_'){
            values.push(s.increment)
          }else{
            values.push(values[values.length - 1] + s.increment);
          }
        }
      });
      return values;
    },

    rateOverN: (serie,N) => {
      let values = new Array(serie.length).fill(0);
      for (i = 0; i < serie.length; i++) {
        values[i] =
          (i >= N ? serie[i] - serie[i - N] : serie[i])/N
        if (values[i] < 0) values[i] = 0;
      }
      return values;
    },
    proportionRateOverN: (bad, good, N) => {
      let max = bad.length >= good.length ? bad.length : good.length;
      let values = new Array(max).fill(0);
      for (i = 0; i < max; i++) {
        let goodDelta =
          i < good.length ? (i >= N ? ((good[i] - good[i - N])>=0?good[i] - good[i - N]:good[i]) : good[i]) : 0;
        let badDelta =
          i < bad.length ? (i >= N ? ((bad[i] - bad[i - N])>=0?bad[i] - bad[i - N]:bad[i]) : bad[i]) : 0;
        if (goodDelta === 0 &&  badDelta == 0){
          values[i] = 0;
        }else{
          values[i] = badDelta / (badDelta + goodDelta);
        }
      }
      return values;
    },

    sumOverN: (serie, N) => {
      if (N <= 0) N = 1; // Ensure N is at least 1
      let values = new Array(serie.length).fill(0);
      let currentSum = 0;
      for (let i = 0; i < serie.length; i++) {
        currentSum = serie[i] || 0; // Add current element, ensuring it's a number
        if (i >= N) {
          currentSum -= serie[i - N] || 0; // Subtract element that falls out of window
        }
        if (currentSum>0){
          values[i] = currentSum;
        }
      }
      return values;
    },

    // Convert minutes to days, hours, minutes string representation
    minutesToTimeString: (minutes) => {
      if (minutes < 0) return '0m';
      
      const days = Math.floor(minutes / 1440); // 24 * 60 = 1440 minutes per day
      const hours = Math.floor((minutes % 1440) / 60);
      const mins = minutes % 60;
      
      let result = '';
      if (days > 0) result += days + 'd';
      if (hours > 0) result += hours + 'h';
      if (mins > 0 || result === '') result += mins + 'm';
      
      return result;
    },

    indexOfValueOver: (threshold, series1, series2) => {
      let overThreshold = -1;
      let returnToGood = -1;
      for (let i = 0; i < series1.length; i++) {
        if (overThreshold < 0) {
          if (series1[i] > threshold && (!series2 || series2[i] > threshold)) {
            overThreshold = i;
          }
        } else {
          if (series1[i] <= threshold && (!series2 || series2[i] <= threshold)) {
            returnToGood = i;
            return `${overThreshold} - ${returnToGood}`;
          }
        }
      }
      return `${overThreshold} - ${returnToGood}`;
    },

    seriesOverThreshold: (threshold, series1, series2) => {
      const results = [];
      if (!series1 || series1.length === 0) {
        return results;
      }

      let startIndex = -1;
      const N = series1.length;

      for (let i = 0; i < N; i++) {
        const s1Value = series1[i];
        let currentIsOverThreshold;

        if (series2) {
          // If series2 is provided, both series must be over the threshold.
          // This also implicitly handles cases where series2 might be shorter than series1,
          // as (i < series2.length) will become false.
          currentIsOverThreshold = s1Value > threshold && i < series2.length && series2[i] > threshold;
        } else {
          // If series2 is not provided, only series1 matters.
          currentIsOverThreshold = s1Value > threshold;
        }

        if (currentIsOverThreshold) {
          if (startIndex === -1) { // Start of a new range
            startIndex = i;
          }
        } else {
          if (startIndex !== -1) { // End of the current range
            results.push([startIndex, i - 1]);
            startIndex = -1;
          }
        }
      }

      // If the loop finishes and we are still in a range (startIndex !== -1)
      if (startIndex !== -1) {
        results.push([startIndex, N - 1]);
      }

      return results;
    },

    expandSeriesDefinition: (definition) => {
      const spec = fn.serieDefFromString(definition);
      const expandedParts = [];
      let lastValue = 0;

      spec.forEach((s) => {
        let initialValue;
        if (s.initial === "#") {
          initialValue = lastValue;
        } else if (typeof s.initial === 'number') {
          initialValue = s.initial;
        } else {
          // For special values like '_', keep them as is
          expandedParts.push(s.initial);
          return;
        }

        if (s.steps === 0) {
          // Single value
          expandedParts.push(initialValue.toString());
          lastValue = initialValue;
        } else {
          // Value with increment and steps
          const operator = s.increment >= 0 ? '+' : '';
          expandedParts.push(`${initialValue}${operator}${s.increment}x${s.steps}`);
          // Calculate the last value for this segment
          lastValue = initialValue + (s.increment * s.steps);
        }
      });

      return expandedParts.join(' ');
    },

  };
  
  // ChartComponent definition
  const ChartComponent = {
    props: {
      alert1: { type: Array, required: true },
      alert2: { type: Array, required: true },
      threshold1: { type: Array, required: true },
      threshold2: { type: Array, required: true },
      bad: { type: Array, required: true },
      good: { type: Array, required: true },
      rate_bad: { type: Array, required: true },
      rate_good: { type: Array, required: true },
      labels: { type: Array, required: true },
      highlightEnabled: { type: Boolean, required: true },
      debounceEnabled: { type: Boolean, required: true },
      debounceTime: { type: [Number, String], required: true },
      showTimeFormat: { type: Boolean, default: false }
    },
    template: `<canvas ref="chartCanvas" style="width: 100%; height: 100%;"></canvas>`,
    mounted() {
      
      this.$nextTick(() => {
        this.renderChart();
      });
    },
    watch: {
      alert1: 'renderChart',
      alert2: 'renderChart',
      threshold1: 'renderChart',
      threshold2: 'renderChart',
      bad: 'renderChart',
      good: 'renderChart',
      rate_bad: 'renderChart',
      rate_good: 'renderChart',
      labels: 'renderChart',
      highlightEnabled: 'renderChart',
      debounceEnabled: 'renderChart',
      debounceTime: 'renderChart',
      showTimeFormat: {
        handler(newVal, oldVal) {
          this.updateTimeFormat();
        },
        immediate: true
      },
      highlightEnabled: {
        handler(newVal, oldVal) {
          if (this._chart) {
            this._chart.options.plugins.highlight.enabled = newVal;
            this._chart.update('none');
          }
        },
        immediate: true
      },
      debounceTime: {
        handler(newVal, oldVal) {
          if (this._chart) {
            this._chart.debounceTime = newVal;
            this._chart.update('none');
          }
        },
        immediate: true
      },
      debounceEnabled: {
        handler(newVal, oldVal) {
          if (this._chart) {
            this._chart.debounceEnabled = newVal;
            this._chart.update('none');
          }
        },
        immediate: true
      },
    },

    computed: {
      showTimeFormatValue() {
        return this.showTimeFormat;
      }
    },
    methods: {
      renderChart() {
        
        if (!this.labels || !this.alert1 || !this.alert2) {
          console.log('Data not ready yet');
          return;
        }
        
        if (this._chart) {
          this._chart.destroy();
        }
        
        const canvas = this.$refs.chartCanvas;
        if (!canvas) {
          console.error('Canvas not found');
          return;
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Could not get 2D context');
          return;
        }
        
        const config = {
          type: 'line',
          data: {
            labels: this.labels,
            datasets: [
              {label:'alert1', data:this.alert1, backgroundColor:'#73bf79', borderColor:'#73bf79'},
              {label:'alert2', data:this.alert2, backgroundColor:'#f2cc0c', borderColor:'#f2cc0c'},
              {label:'threshold1', data:this.threshold1, backgroundColor:'#6495ed', borderColor:'#6495ed', pointRadius:0, borderDash:[10, 10]},
              {label:'threshold2', data:this.threshold2, backgroundColor:'#ed6495', borderColor:'#ed6495', pointRadius:0, borderDash:[10, 10]},
              {label:'bad', data:this.bad, backgroundColor:'#ffaaaa', borderColor:'#ffaaaa', hidden:true},
              {label:'good', data:this.good, backgroundColor:'#aaaaff', borderColor:'#aaaaff', hidden:true},
              {label:'bad rate', data:this.rate_bad, backgroundColor:'#ff4500', borderColor:'#ff4500', hidden:true},
              {label:'good rate', data:this.rate_good, backgroundColor:'#007fff', borderColor:'#007fff', hidden:true},
            ]
          },
          plugins: [highlightPlugin],
          options: {
            datasets:{
              line:{
                borderWidth:1,
                pointRadius: 1
              }

            },

            animation: {
              duration: 0
            },
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              highlight: { enabled: this.highlightEnabled },
              zoom: {
                zoom: { wheel: { enabled: false }, pinch: { enabled: false }, mode: 'xy' },
                pan: { enabled: true },
              },
              legend: { labels: { color: '#D8D9DA' } },
              tooltip: {
                callbacks: {
                  title: (context) => {
                    const dataIndex = context[0].dataIndex;
                    const timeString = this.showTimeFormatValue ? 
                      `Time: ${fn.minutesToTimeString(dataIndex)} (${dataIndex})` :
                      `Step: ${dataIndex}`;
                    return timeString;
                  }
                }
              }
            },
            interaction: { intersect: false },
            scales: {
              x: {
                display: true,
                title: { display: true },
                ticks: {
                  display: true,
                  maxTicksLimit: 100,
                  color: '#B4B7C0',
                  callback: (value) => {
                    const tickValue = this.showTimeFormatValue ? fn.minutesToTimeString(value) : value;
                    return tickValue;
                  }
                },
                grid: { color: '#3A3D42' },
              },
              y: {
                display: true,
                title: { display: true, text: 'Value', color: '#D8D9DA' },
                suggestedMin: 0,
                ticks: { color: '#B4B7C0' },
                grid: { color: '#3A3D42' }
              },
              y_errors: {
                position: 'right',
                display: true,
                title: { display: true, text: 'Error Related Value', color: '#D8D9DA' },
                suggestedMin: 0,
                suggestedMax: 1,
                ticks: { color: '#B4B7C0' },
                grid: { drawOnChartArea: false, color: '#3A3D42' }
              },
            },
          },
        };
        
        try {
          this._chart = new Chart(ctx, config);
          this._chart.debounceEnabled = this.debounceEnabled;
          this._chart.debounceTime = this.debounceTime;
        } catch (error) {
          console.error('Error creating chart:', error);
        }
      },
      updateTimeFormat() {
        if (this._chart) {
          // Update the x-axis ticks callback
          this._chart.options.scales.x.ticks.callback = (value) => {
            const tickValue = this.showTimeFormatValue ? fn.minutesToTimeString(value) : value;
            return tickValue;
          };
          
          // Update the tooltip callback
          this._chart.options.plugins.tooltip.callbacks.title = (context) => {
            const dataIndex = context[0].dataIndex;
            return this.showTimeFormatValue ? 
              `Time: ${fn.minutesToTimeString(dataIndex)} (${dataIndex})` :
              `Step: ${dataIndex}`;
          };
          
          // Force chart update
          this._chart.update('none');
        }
      },
    },
    beforeUnmount() {
      if (this._chart) {
        this._chart.destroy();
      }
    }
  };

    Chart.register(ChartZoom);

    const highlightPlugin = {
      id: "highlight",
      beforeDraw: (chart) => {
        // Check if the plugin is enabled via chart options
        if (!chart.options?.plugins?.highlight?.enabled) {
          return;
        }

        const { ctx, chartArea, data, scales } = chart;
        if (!chartArea || !data || !scales.x) { // Ensure essential components are available
          return;
        }

        const datasets = data.datasets;
        if (!datasets.length){ 
         return
        }
        const alert1Dataset = datasets.find(ds => ds.label === 'alert1');
        const alert2Dataset = datasets.find(ds => ds.label === 'alert2');
        const threshold1Dataset = datasets.find(ds => ds.label === 'threshold1');
        const threshold2Dataset = datasets.find(ds => ds.label === 'threshold2');

        const alert1Data = alert1Dataset.data;
        const alert2Data = alert2Dataset.data;
        const threshold1Data = threshold1Dataset.data;
        const threshold2Data = threshold2Dataset.data;

        // Determine the number of points to check, limited by the shortest series
        const numPoints = Math.min(alert1Data.length, alert2Data.length, threshold1Data.length);
        if (numPoints === 0) {
          return;
        }

        ctx.save();
        ctx.fillStyle = "rgba(180, 85, 85, 0.6)"; // A semi-transparent orange for highlighting

        let inHighlightSegment = false;
        let segmentStartIndex = 0;
        const useDebounce = chart.debounceEnabled || false;
        const debounceSteps = useDebounce ? (parseInt(chart.debounceTime, 10) || 0) : 0;


        let effectiveAlertStates = new Array(numPoints).fill(false);
        let consecutiveOverThreshold = 0;

        for (let i = 0; i < numPoints; i++) {
          const isOverThreshold = alert1Data[i] > threshold1Data[i] && alert2Data[i] > threshold2Data[i];

          if (isOverThreshold && !inHighlightSegment) {
            consecutiveOverThreshold++;
            if (consecutiveOverThreshold >= debounceSteps) {
              inHighlightSegment = true;
              segmentStartIndex = i;
            }
          } else if (!isOverThreshold && inHighlightSegment) {
            if (consecutiveOverThreshold>=debounceSteps){
              const xPixelStart = scales.x.getPixelForValue(segmentStartIndex);
              const xPixelEnd = scales.x.getPixelForValue(i); // Segment is [segmentStartIndex, i-1]
              ctx.fillRect(xPixelStart, chartArea.top, xPixelEnd - xPixelStart, chartArea.bottom - chartArea.top);
            }
            inHighlightSegment = false;
            consecutiveOverThreshold=0;
          }
        }

        // If the loop finishes and we are still in a highlight segment
        if (inHighlightSegment) {
          const xPixelStart = scales.x.getPixelForValue(segmentStartIndex);
          const xPixelEnd = scales.x.getPixelForValue(numPoints); // Highlight till the end of the last valid point's bar
          ctx.fillRect(xPixelStart, chartArea.top, xPixelEnd - xPixelStart, chartArea.bottom - chartArea.top);
        }

        ctx.restore();
      },
    };

    const { createApp } = Vue;
    
    const app = createApp({
      methods: {
      },
      setup() {
        
        // localStorage keys
        const LS_KEYS = {
          BAD: 'slo_helper_bad_v1', // Added _v1 in case of structure changes later
          GOOD: 'slo_helper_good_v1',
          SHORT: 'slo_helper_short_v1',
          LONG: 'slo_helper_long_v1',
          THRESHOLD1: 'slo_helper_threshold1_v1',
          THRESHOLD2: 'slo_helper_threshold2_v1',
          HIGHLIGHT_ENABLED: 'slo_helper_highlight_enabled_v1', // Keep for consistency
          SELECTED_FORMULA: 'slo_helper_selected_formula_v1',
          DEBOUNCE_ENABLED: 'slo_helper_debounce_enabled_v1', 
          DEBOUNCE_TIME: 'slo_helper_debounce_time_v1',
          SHOW_SERIES_VALUES: 'slo_helper_show_series_values_v1',
          SHOW_TIME_FORMAT: 'slo_helper_show_time_format_v1'
        };


        const initialGood = localStorage.getItem(LS_KEYS.GOOD) || "0+1000x60 #+850x10 #+1000x60 #+0x60 #+850x10 #+1000x60";
        const initialBad = localStorage.getItem(LS_KEYS.BAD) || "0+0x60 150+150x10 #+0x60 #+0x60 #+150x10 #+0x60";
        const initialShort = localStorage.getItem(LS_KEYS.SHORT) || 0;
        const initialLong = localStorage.getItem(LS_KEYS.LONG) || 0;
        const initialThreshold1 = localStorage.getItem(LS_KEYS.THRESHOLD1) || 0;
        const initialThreshold2 = localStorage.getItem(LS_KEYS.THRESHOLD2) || 0;
        const initialSelectedFormula = localStorage.getItem(LS_KEYS.SELECTED_FORMULA) || 'proportionRateOverN';
        const initialHighlightEnabled = localStorage.getItem(LS_KEYS.HIGHLIGHT_ENABLED);
        const initialDebounceEnabled = localStorage.getItem(LS_KEYS.DEBOUNCE_ENABLED); // Use the new key
        const initialDebounceTime = localStorage.getItem(LS_KEYS.DEBOUNCE_TIME) || 0;
        const initialShowSeriesValues = localStorage.getItem(LS_KEYS.SHOW_SERIES_VALUES);
        const initialShowTimeFormat = localStorage.getItem(LS_KEYS.SHOW_TIME_FORMAT);
        const initialTests = document.location.toString().indexOf('test=true')>0;

        let bad         = Vue.ref(initialBad);
        let bad_length  = Vue.ref(0)
        let good        = Vue.ref(initialGood);
        let good_length = Vue.ref(0)
        let step_values = Vue.ref({bad_values: [], good_values: []});
        let short       = Vue.ref(initialShort !== '' ? parseInt(initialShort, 10) : 5);
        let long        = Vue.ref(initialLong !== '' ? parseInt(initialLong, 10) : 60);
        let threshold1  = Vue.ref(initialThreshold1 !== '' ? parseFloat(initialThreshold1) : 0.01344);
        let threshold2  = Vue.ref(initialThreshold2 !== '' ? parseFloat(initialThreshold2) : 0.01344);
        let highlightEnabled = Vue.ref(initialHighlightEnabled !== null ? JSON.parse(initialHighlightEnabled) : true);
        let debounceEnabled  = Vue.ref(initialDebounceEnabled !== null ? JSON.parse(initialDebounceEnabled) : true);
        let debounceTime     = Vue.ref(initialDebounceTime !== null ? parseInt(initialDebounceTime, 10) : 5); // Default to 5 steps
        let selectedFormula  = Vue.ref(initialSelectedFormula);
        let showHelpModal    = Vue.ref(false);
        let showSeriesValues = Vue.ref(initialShowSeriesValues !== null ? JSON.parse(initialShowSeriesValues) : false);
        let showTimeFormat   = Vue.ref(initialShowTimeFormat !== null ? JSON.parse(initialShowTimeFormat) : true);
        let badSeriesData    = Vue.ref([]);
        let goodSeriesData   = Vue.ref([]);
        let expandedBad      = Vue.ref('');
        let expandedGood     = Vue.ref('');

        // --- COMPUTED CHART DATA ---
        const chartData = Vue.reactive({
          alert1: [],
          alert2: [],
          threshold1: [],
          threshold2: [],
          bad: [],
          good: [],
          rate_bad: [],
          rate_good: [],
          labels: []
        });

        // Function to update chart data
        const updateChartData = () => {
          const def_bad = fn.serieDefFromString(bad.value);
          const def_good = fn.serieDefFromString(good.value);
          const serie_bad = fn.makeSerie(def_bad);
          const serie_good = fn.makeSerie(def_good);
          bad_length.value = serie_bad.length;
          good_length.value = serie_good.length;
          const rate_bad = fn.rateOverN(serie_bad, 1);
          const rate_good = fn.rateOverN(serie_good, 1);
          step_values.value = { bad_values: serie_bad, good_values: serie_good, rate_bad, rate_good };
          // Calculate expanded definitions
          expandedBad.value = fn.expandSeriesDefinition(bad.value);
          expandedGood.value = fn.expandSeriesDefinition(good.value);
          let alert1, alert2;
          if (selectedFormula.value === 'countOverN') {
            alert1 = fn.sumOverN(serie_bad, short.value);
            alert2 = fn.sumOverN(serie_bad, long.value);
          } else {
            alert1 = fn.proportionRateOverN(serie_bad, serie_good, short.value);
            alert2 = fn.proportionRateOverN(serie_bad, serie_good, long.value);
          }
          const max = Math.max(serie_bad.length, serie_good.length);
          const th1 = fn.makeSerieConstant(parseFloat(threshold1.value), max);
          const th2 = fn.makeSerieConstant(parseFloat(threshold2.value), max);
          
          // Update the reactive object
          chartData.alert1 = alert1;
          chartData.alert2 = alert2;
          chartData.threshold1 = th1;
          chartData.threshold2 = th2;
          chartData.bad = serie_bad;
          chartData.good = serie_good;
          chartData.rate_bad = rate_bad;
          chartData.rate_good = rate_good;
          chartData.labels = new Array(max).fill(0).map((_, i) => i.toString());
          
        };

        // Initial update
        updateChartData();

        // Throttled update function for chart data
        let updateTimeout = null;
        let isUpdating = Vue.ref(false);
        const throttledUpdateChartData = () => {
          if (updateTimeout) {
            clearTimeout(updateTimeout);
          }
          isUpdating.value = true;
          updateTimeout = setTimeout(() => {
            updateChartData();
            isUpdating.value = false;
          }, 500); // 300ms throttle
        };

        // Watch for changes and update chart data with throttling
        Vue.watch([bad, good], throttledUpdateChartData);
        Vue.watch([short, long, threshold1, threshold2, selectedFormula], updateChartData);

        // Watchers to save to localStorage
        Vue.watch(bad, (newValue) => { localStorage.setItem(LS_KEYS.BAD, newValue); });
        Vue.watch(good, (newValue) => { localStorage.setItem(LS_KEYS.GOOD, newValue); });
        Vue.watch(short, (newValue) => { localStorage.setItem(LS_KEYS.SHORT, newValue.toString()); });
        Vue.watch(long, (newValue) => { localStorage.setItem(LS_KEYS.LONG, newValue.toString()); });
        Vue.watch(threshold1, (newValue) => { localStorage.setItem(LS_KEYS.THRESHOLD1, newValue.toString()); });
        Vue.watch(threshold2, (newValue) => { localStorage.setItem(LS_KEYS.THRESHOLD2, newValue.toString()); });
        Vue.watch(selectedFormula, (newValue) => { localStorage.setItem(LS_KEYS.SELECTED_FORMULA, newValue); });
        Vue.watch(debounceEnabled, (newValue) => { 
          localStorage.setItem(LS_KEYS.DEBOUNCE_ENABLED, newValue); 
        });

        Vue.watch(debounceTime, (newValue) => { 
          localStorage.setItem(LS_KEYS.DEBOUNCE_TIME, newValue); 
        });

        Vue.watch(showSeriesValues, (newValue) => { 
          localStorage.setItem(LS_KEYS.SHOW_SERIES_VALUES, newValue); 
        });

        Vue.watch(showTimeFormat, (newValue) => { 
          localStorage.setItem(LS_KEYS.SHOW_TIME_FORMAT, newValue); 
        });


        const toggleHelpModal = () => {
          showHelpModal.value = !showHelpModal.value;
        };

        const copyToClipboard = async (text) => {
          try {
            await navigator.clipboard.writeText(text);
            // Optional: Add visual feedback here if desired
          } catch (err) {
            console.error('Failed to copy text: ', err);
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
          }
        };

        if (initialTests && runUnitTests){
          runUnitTests();
        }

        const result = {
          bad, 
          bad_length,
          good, 
          good_length,
          short, 
          step_values,
          long, 
          threshold1,
          threshold2,
          highlightEnabled, // Expose to template for v-model
          debounceEnabled,
          debounceTime,
          selectedFormula, // Expose for v-model on select
          showHelpModal, // Expose for modal visibility
          toggleHelpModal, // Expose for modal toggle
          showSeriesValues, // Expose for v-model on checkbox
          showTimeFormat, // Expose for v-model on checkbox
          expandedBad, // Expose expanded bad definition
          expandedGood, // Expose expanded good definition
          copyToClipboard, // Expose for copy functionality
          chartData, // Expose the reactive object
          isUpdating, // Expose updating status
        };
        
        return result;
      },
    });

    
    // Register the ChartComponent
    app.component('chartcomponent', ChartComponent);

      app.mount("#app");
  </script>
  <style>
    html, body {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      background-color: #161719; /* Grafana-like dark background */
      color: #D8D9DA; /* Grafana-like text color */
      margin: 0;
      padding: 10px; /* Further reduced padding for body */
      display: flex; /* Ensure body takes full height if needed */
      flex-direction: column;
      height: 100vh; /* Full viewport height */
    }
    .main-container {
      display: flex;
      flex-grow: 1; /* Allows main-container to fill available space */
      gap: 10px; /* Reduced space between config panel and chart */
      height: calc(100vh - 20px); /* Full height minus body padding */
    }
    .config-panel { /* Formerly #app, now a class for the left panel */
      background-color: #1F2126; /* Slightly lighter panel background */
      padding: 10px; /* Reduced padding */
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      width: 380px; /* Made panel narrower */
      flex-shrink: 0; /* Prevent panel from shrinking */
      overflow-y: auto; /* Allow scrolling if content exceeds height */
    }
    .chart-container {
      flex-grow: 1; /* Chart container takes remaining space */
      background-color: #1F2126; /* Match panel background for the chart area */
      border-radius: 4px;
      padding: 10px; /* Reduced padding around the canvas */
      display: flex; /* To help center/contain the canvas if needed */
      position: relative; /* For responsive chart */
      min-height: 400px; /* Ensure minimum height for chart visibility */
      height: 100%; /* Take full height of parent */
    }
    

    h2 {
      color: #E0E0E0;
      margin-top: 0;
      border-bottom: 1px solid #3A3D42;
      padding-bottom: 8px; /* Reduced padding */
    }
    input, button, select { /* Added select here */
      font-family: "Courier", "Monaco";
      background-color: #282A2E;
      color: #D8D9DA;
      /* For select, ensure the arrow matches the text color if possible, or use a standard one */
      border: 1px solid #3E4147;
      padding: 6px 10px; /* Reduced padding for inputs and buttons */
      border-radius: 3px;
      margin-right: 5px; /* Spacing between inline elements */
      margin-bottom: 6px; /* Reduced bottom margin */
    }
    button {
      cursor: pointer;
      background-color: #36A2EB; /* A Grafana-like blue for buttons */
      border-color: #36A2EB;
    }
    button:hover {
      background-color: #2E8AC5;
    }
    canvas {
      /* Canvas itself doesn't need background if container has it */
      /* Ensure canvas is responsive within its container */
      max-width: 100%;
      max-height: 100%;
    }
    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Darker overlay */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000; /* Ensure it's on top */
    }
    .modal-content {
      background-color: #282A2E; /* Grafana panel-like background */
      color: #D8D9DA;
      padding: 20px; /* Slightly reduced modal padding */
      border-radius: 5px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.5);
      width: 80%;
      max-width: 700px; /* Max width for readability */
      max-height: 80vh; /* Max height */
      overflow-y: auto; /* Scroll if content overflows */
      position: relative; /* For positioning the close button */
    }
    .modal-content h2, .modal-content h4 {
      color: #E0E0E0;
      margin-top: 0;
      border-bottom: 1px solid #3A3D42;
      padding-bottom: 10px;
    }
    .modal-content ul {
      padding-left: 20px;
    }
    .close-button {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 28px;
      font-weight: bold;
      color: #B4B7C0;
      cursor: pointer;
    }
    .close-button:hover {
      color: #D8D9DA;
    }
    /* Adjust input sizes for narrower panel */
    .config-panel input[size="100"] {
      width: calc(100% - 20px); /* Adjusted for new padding (6px*2 for input + some breathing room) */
    }

    .alert {
      display: inline-block;
      width: 10px;
      height: 10px;

    }
    .alert1 {
      background-color:#73bf79;
    }
    .alert2 {
      background-color:#f2cc0c;
    }
    select {
    width: 200px;
    }
    
    /* Series Values Section Styles */
    .series-values-container {
      background-color: #1F2126;
      padding: 15px;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .series-values-container h3 {
      color: #E0E0E0;
      margin-top: 0;
      margin-bottom: 15px;
      border-bottom: 1px solid #3A3D42;
      padding-bottom: 8px;
    }
    
    .series-columns {
      display: flex;
      gap: 20px;
    }
    
    .series-column {
      flex: 1;
      background-color: #282A2E;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #3E4147;
    }
    
    .series-column h4 {
      color: #D8D9DA;
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 14px;
      border-bottom: 1px solid #3A3D42;
      padding-bottom: 5px;
    }
    
    .series-data {
      overflow-y: auto;
      font-family: "Courier", "Monaco", monospace;
      font-size: 12px;
    }
    
    .series-item {
      display: flex;
      padding: 2px 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .series-item:nth-child(even) {
      background-color: rgba(255, 255, 255, 0.05);
    }
    
    .series-item .index {
      color: #B4B7C0;
      width: 40px;
      flex-shrink: 0;
    }
    
    .series-item .value {
      margin-left: 10px;
      width: 4rem;
    }
    


    .bad_events {
      color: #ed7591;
    }

    .copy-button {
      background: none;
      border: none;
      color: #B4B7C0;
      cursor: pointer;
      padding: 0px;
      margin-left: 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      min-height: 24px;
    }

    .copy-button:hover {
      background-color: #3E4147;
      color: #D8D9DA;
      transform: scale(1.05);
    }

    .copy-button:active {
      transform: scale(0.95);
    }

    .expanded-definition-mini {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: "Courier", "Monaco", monospace;
      font-size: 11px;
      opacity: 0.8;
    }

    .expanded-definition-mini code {
      background: none;
      border: none;
      padding: 0;
      color: inherit;
      flex: 1;
      word-break: break-all;
    }

    .definition-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      font-family: "Courier", "Monaco", monospace;
      font-size: 12px;
    }
  </style>
</body>
</html>
